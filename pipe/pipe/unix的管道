 UNIX里的管道

管道是UNIX操作系统最强大和最具特色的性能之一 
无名管道是一个特殊的打开文件，只能在程序中由系统调用PIPE（P）生成。其中参数P定义如下： 
INT P[2]； 
无名管道由一个在基本文件系统存储设备上的INODE，一个与其相连的内存INODE，两个打开文件控制块（分别对应管道的信息发送端和信息接收 端）及其所属进程的描述信息来标识，在系统执行PIPE（P）命令行之后生成。并在P[0]中返回管道的读通道打开文件描述等，在P[1]中返回管道的写 通道打开文件描述符。从结构上看，无名管道没有文件路径名，不占用文件目录项，因此文件目录结构中的链表不适用于这种文件，它只是存在于打开文件结构中的 一个临时文件，随其所依附的进程的生存而生存，当进程终止时，无名管道也随之消亡。 
送入管道的信息一旦被读进程取用就从管道中消失了，读写操作之间符合先进先出的队列原则。 
管道文件是进程间通信的工具，为了尽量少的占用系统存储资源，一般系统均将其限制为最大长度为4096（PIPSIZ）字节的小型文件。当欲写入 的消息超过4096字节时，就产生了读、写进程之间的同步问题。首先写操作查找PIPE文件中当前指针的偏移量F-OFFSET，然后从此位置开始尽量写 入信息，当长度达到4096字节时，系统控制写进程进入睡眠状态，一直等待读进程取走全部信息时，文件长度指针置0，写进程才被唤醒继续工作。 
为防止多个进程同时读写一个管道文件而产生混乱，在管道文件的INODE标志字I-FLAY项中设置了ILOCK标志项，以设置软件锁的方式实现多进程间对管道文件的互斥使用。 

无名管道存在着如下两个严重的缺点。 
第一， 无名管道只能用于连接具有共同祖先的进程。由于无名管道是在程序中建立的，系统伴随无名管道的生成而分配随机的读/ 写文件描述符，程序 的每一次运行其读/写文件描述符均不相同，只有靠父子进程间的继承关系才能传递管道文件描述符，这样就导致只有亲属进程间才能使用同一无名管道。这一缺点 是程序员在开发全系统范围内的服务程序时所不能忍受的。如网络控制服务程序要求各进程在并发执行的同时利用管道与其他服务进程进行通信，然后再脱离，这是 利用无名管道无法实现的。 
第二、 无名管道是依附进程而临时存在的。无名管道随其所依附的进程的生存而生存，当进程终止时，无名管道也随之消亡，它不是永久存在于系统中的。 
为了弥补无名管道的不足，伴随UNIX SYSTEM III的出台推出了一种无名管道的变种-有名管道，它常被称为FIFO。有名管道除继承了无名管道的所有特性优点之外，还屏弃了无名管道的两个缺点。 
首先，FIFO是一种永久性的机构，它具有普通的UNIX系统文件名。在系统下可利用MKNOD命令建立永久的管道，除非刻意删除它，否则它将一直保持在系统中。 
其次，正是由于有名管道以“文件名”来标识，所以只要事先约定某一特定文件名，那样所有知道该约定的服务进程，不论它们之间是否有亲属关系，都可以便利地利用管道进行通信。 

在unix中命名管道是一种先进先出（FIFO）的数据结构，它允许两个进程通过管道联接实现信息交换。  
在Unix系统中，命名管道是一种特殊类型的文件，因此可以对命名管道进行读写操作；当然，同样  
也会有读写和执行等权限的限制。   

　　通过下面的命令可以创建一个命名管道：  
　　/etc/mknod pipe_name p   

　　其中“pipe_name”是要创建的命名管道的名字，参数p 必须出现在命名管道名字之后。   

　　命名管道文件被创建后，一些进程就可以不断地将信息写入命名管道文件里，而另一些进程也  
可以不断地从命名管道文件中读取信息。对命名管道文件的读写操作是可以同时进行的。下面的例子  
显示命名管道的工作过程。   

　　进程A、B、C中运行的程序只是一条简单的echo命令，它们不断地把信息写入到命名管道文件  
/tmp/pipe1中。与此同时，程序中的“read msg” 命令不断地从命名管道文件/tmp/pipe1中读取这些  
信息，从而实现这些进程间的信息交换。   

　　程序执行时，首先创建命名管道文件，此时程序处于等待状态，直到A、B、C进程中某一个进程往  
命名管道中写入信息时，程序才继续往下执行。使用rm命令可以删除命名管道文件从而清除已设置的  
命名管道。   

　　下面是一个用于记录考勤的例子：   

　　在主机上运行的程序/tmp/text产生命名管道/tmp/pipe1，并不断地从命名管道中读取信息送屏幕  
上显示。   

/tmp/text程序：  
if [ ! －p /tmp/pipe1 ]  
then  
  /etc/mknode /tmp/pipe1 p  
fi  
while :  
do  
  read msg  
  if [ “＄msg" = “" ]  
  then  
continue  
  else  
echo “＄msg"  
  fi  
done < /tmp/pipe1 

　　在终端上运行的是雇员签到程序/tmp/text1。每个雇员在任何一台终端上键入自己的名字或代码， 
程序/tmp/text1将把这个名字连同当时的签到时间送入命名管道。 

/tmp/text1程序： 
tty=‘who am I | awk ‘{print ＄2}’’ 
while : 
do 
echo “Enter your name: \c" > /dev/＄tty  
      read name  
      today=‘date’  
      echo “＄name\t＄today"  
      done > /tmp/pipe1  

　　当雇员从终端上输入自己的姓名后，运行/tmp/text程序的主机将显示类似下面的结果：   

wang Thu Jan 28 09:29:26 BTJ 1999  
he Thu Jan 28 09:29:26 BTJ 1999  
cheng Thu Jan 28 09:30:26 BTJ 1999  
zhang Thu Jan 28 09:31:26 BTJ 1999 

named pipes(命名管道）管道具有很好的使用灵活性，表现在：  
　　1) 既可用于本地，又可用于网络。  
　　2) 可以通过它的名称而被引用。  
　　3) 支持多客户机连接。  
　　4) 支持双向通信。  
　　5) 支持异步重叠I/O操作。

Unix管道技术
管道是Unix操作系统最强大和最具特色的性能之一，从功能上讲，管道机制提供了一种在各进程之间大量传输信息的通道；而从本质上讲，管道是一个特殊的文件。管道是以Unix文件系统为基础而设计的，它具有对普通文件操作的一般特性，如用于普通文件的打开（OPEN）、读（READ）、写（WRITE）、关闭（CLOSE）等系统调用同样可以作用于管道。
Unix操作系统下的管道分为无名管道（PIPE）和有名管道（FIFO）两种，它们在不同的领域下有效地完成了相关进程之间的数据共享和信息交换，从而保证了进程间的协同工作。与Unix系统提供的其他进程通信机制，如信号（SIGNAL）、消息传送（MESSAGE PASSING）、共享内存（SHARED MEMORY）等相比，管道机制具有如下三个突出的特点：
（1）发送进程能以比较简单的方式，源源不断地把产生的消息以自然流的方式写入管道，而不需要考虑对每次传送的信息长度的限制。
（2）接收进程能在适当的时机从管道按需提取信息，同样也不必以固定的消息长度为单位进行。
（3）发送和接收进程都能以一定的方式了解对方进程是否存在，并且可以通过管道的现存消息情况（管道空、管道有信息、管道满）等相互协调动作。
无名管道（PIPE）
无名管道是一个特殊的打开文件，只能在程序中由系统调用PIPE（P）生成。其中参数P的定义为：
INT P[2]；
无名管道由一个在基本文件系统存储设备上的INODE，一个与其相连的内存INODE，两个打开文件控制块（分别对应管道的信息发送端和信息接收端）及其所属进程的描述信息来标识，在系统执行PIPE（P）命令行之后生成。在P[0]中返回管道的读通道打开文件描述符；在P[1]中返回管道的写通道打开文件描述符。从结构上看，无名管道没有文件路径名，不占用文件目录项，因此文件目录结构中的链表不适用于这种文件，它只是存在于打开文件结构中的一个临时文件，随其所依附的进程的生存而生存，当进程终止时，无名管道也随之消亡。
有名管道（FIFO）
无名管道存在着如下两个严重的缺点：
第一、无名管道只能用于连接具有共同祖先的进程；
第二、无名管道是依附进程而临时存在的，并不是永久存在于系统中。
为了弥补无名管道的不足，伴随Unix SYSTEM III的出台推出了一种无名管道的变种——有名管道，它常被称为FIFO。有名管道除继承了无名管道的所有特性优点之外，还摒弃了无名管道的两个缺点。首先，FIFO是一种永久性的机构，它具有普通的Unix系统文件名。在系统下可利用MKNOD命令建立永久的管道，除非刻意删除它，否则它将一直保持在系统中。其次，正是由于有名管道以文件名来标识，所以只要事先约定某一特定文件名，那样所有知道该约定的服务进程，不论它们之间是否有亲属关系，都可以方便地利用管道进行通信。
FIFO有两种建立方式。
在系统命令级建立FIFO：
$/ETC/MKNOD    FIFO    P
其中参数P用以标识建立一个管道特殊文件。
在程序中建立FIFO：
MKNOD（“FIFO”，010600，0）；
其中八进制数“010600”用以标识建立一个FIFO文件。
FIFO 和无名管道在系统内核层合用了大量的代码段，它的读、写流程与无名管道的读、写流程基本一致。值得注意的是，Unix系统规定，为了资源利用的合理性，如果没有进程在某FIFO用于写之前打开时，有进程先打开FIFO用于读的话，那样该读进程将被阻塞，直到有另一个进程打开该FIFO用于写，反之亦然。解决这一问题的最好方法是推出一个后台进程将该FIFO以读、写双重的方式打开操作。





