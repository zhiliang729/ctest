//
//  main.c
//  signal
//
//  Created by zhangliang on 14-4-15.
//  Copyright (c) 2014年 com.gooagoo.Gooagoo. All rights reserved.
//

#include <stdio.h>

/*
    信号是传送给进程的事件通知，它可以完成进程间异步事件的通信，比如用户按“Ctrl + c” 组合键，unix内核将产生程序终止号
 SIGINT, 并通知进程组终止进程。unix为进城定义了一组事件，并分别将每个事件定义为“SIG”开头的信号宏，比如SIGALRM表示
 定时器信号等。
    1.信号产生
        导致信号产生的原因总体来说有三种可能：
            1.程序错误-----当硬件出现异常、除数为0或者软件非法访问等情况时产生。
            2.外部事件-----当定时器到达、用户按键中断或者进城调用abort等信号发送函数时产生。
            3.显式请求-----当进程调用kill、raise等信号发送函数或者用户执行shell命令kill传递信号时产生。
        每个进程都有一个域用来存储信号的接收情况，域中每个位bit对应一个专门信号。进程在接收信号时设置之，在处理信号时清除之。故进程可以并行接受不同的信号，但如无特殊处理机制（如信号阻塞等），不能记载统一信号在处理前的接收次数
    2.信号处理
        当进程收到信号时有如下三种处理方式。
            1.系统默认-----进程对信号的一般处理方式，由unix内核完成。系统对不同的信号采用不同的默认处理方式。
                方式                                      描述
                终止                                      进程退出
                忽略                                      丢弃信号
                core-dump                                 进程退出，并将进程在内存的数据和存储器状态以某种
                                                            特殊的格式转存到文件系统“core”文件中。本类信号在程序异常时发生，产生core文件供程序员参考
                挂起                                      进程进入睡眠态
                继续                                      唤醒睡眠中的进程。“挂起”和“继续”处理方式主要应用于
                                                        程序调试过程中，如进程单步调试等
            2.忽略信号-----信号接收后，立即丢弃。注意信号SIGSTOP和SIGKILL不能忽略，否则将会出现超级用户无法停止的进程，另外建议对某些信号不能忽略，比如硬件异常信号等。
            3.捕获信号-----进程接收信号，并且调用自定义的代码响应之。比如守护进程生成函数InitServer就调用ClearChild响应信号SIGCHLD。
    3.信号分类
            1.软硬件异常类信号------一般在程序执行了某些严重不合法的动作时发出。
                SIGABRT：   调用abort函数生成的信号。函数abort退出进程，与函数exit类似。
                SIGBUS/SIGSEGV： 硬件错误-非法地址访问。本信号在总线错误时发出。
                SIGEMT：    硬件错误  本信号在仿真器自陷时发出，一般由于操作系统不能正确模拟软件指令而产生。
                SIGFPE：      浮点计算错误。本信号在浮点运算异常时发出，如浮点溢出、除数为0等
                SIGILL：     CPU检测到某进程执行了非法硬件指令时发出。如程序本身出现代码错误、试图执行数据段或堆栈溢出等。
                SIGPWR：     本信号在缺少电力时发出。
                SIGSEGV:    "段违例"信号，在进程访问无效或无权限内存地址时发出。指示进程进行了无效的内存访问
                SIGSYS：     无效的系统调用。比如指示系统调用的参数类型错误等。
                SIGTRAP：    该信号由断点指令或其他trap陷阱指令产生，主要供调试程序时应用。
                SIGXCPU：    进程执行时间超过了分配给该进程的CPU时间，系统产生该信号并发送给该进程。
                SIGXFSZ：    本信号在进程扩大文件过程中超过文件最大长度的限制时发出。
            2.终止进程类信号-----本类信号能够终止进程的运行，部分信号生成core文件。
                SIGHUP：    用户在登录unix时，系统将为其分配终端。本信号在用户退出unix登录时发送。终端连接正常或非正常断开时发出，该终端上所有的进程无论是前台的还是后台的都将受到信号。信号SIGHUP的默认操作方式是终止进程，因此在终端断开连接后，系统将终止该终端上德所有前后台进程。这就是后台执行的进程在用户退出登陆后会消失的原因。但在shell中执行的守护进程不受终端控制。
                SIGINT：     用户键入中断命令一般是按下＜Ctrl+C 或者delete键＞组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。用于通知前台进程组终止进程。
                SIGKILL：    无条件终止进程。本信号不能被忽略、处理和阻塞。默认动作为终止进程。它向系统管理员提供了一种可以杀死任何进程的方法。
                SIGQUIT：        当用户键入退出命令通常是按下＜Ctrl+\＞组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序（前台进程组）发出此信号。默认动作为终止进程并产生core文件。
                SIGTERM：        程序结束（terminate）信号，与SIGKILL不同的是，该信号可以被阻塞和处理。通常用来要求程序正常退出。执行Shell命令kill时，缺少产生这个信号。
            3.进程挂起类信号-----本类信号导致进程进入休眠状态，一般应用于程序调试和资源抢占中。
                SIGCONT：        激活处于休眠状态的进程，如果进程不处于休眠态将忽略信号。本信号不能被阻塞，但可以捕获，用于完成进程状态变化时执行特定的工作。比如vi在收到本信号后将刷新屏幕。让一个暂停的进程继续执行。
                SIGSTOP：        停止（stopped）进程的执行。注意它和SIGTERM以及SIGINT的区别：该进程还未结束，只是暂停执行。本信号不能被忽略、处理和阻塞。默认动作为暂停进程。
                SIGTSTP：        交互式挂起进程运行。停止进程的动作，但该信号可以被处理和忽略。按下＜Ctrl+Z＞组合键时发出这个信号。默认动作为暂停进程。
                SIGTTIN：        当后台进程要从用户终端读数据时，该终端中的所有进程会收到SIGTTIN信号。默认动作为暂停其他进程。
                SIGTTOU：        该信号类似于SIGTIN，在后台进程要向终端输出数据时产生。默认动作为暂停其他进程。
            4.定时器类信号------本类信号一般由函数alram和色titimer发出，用于指示定时器定时完毕。
                SIGALRM         本信号在alarm函数定义的定时器到期时发出.SIGALRM：定时器超时，超时的时间由系统调用alarm设置。
                SIGPROF         类似于SIGVTALRM，它在该进程占用的CPU时间还包括执行系统调用的时间到期时发出。
                SIGVTALRM：      虚拟时钟超时时产生该信号。类似于SIGALRM，但是它只计算该进程占用的CPU时间。比如函数setitimer设置的定时器到期时会产生此信号。
            5.其他信号-------包括预留信号、I/O信号等。
                SIGCHLD：        子程序结束时，父进程会收到这个信号。如果父进程没有处理这个信号，也没有等待（wait）子进程，子进程虽然终止，但会在内核进程表中占有表项，这时的子进程称为僵死进程。为了避免这种情况，父进程可以采取忽略本信号、捕捉本信号、wait子进程或者父进程先终止，由进程init自动接管子进程等方式。
                SIGPIPE：        Broken pipe：向一个没有读端的管道写数据。
 */

int main(int argc, const char * argv[])
{
    return 0;
}

